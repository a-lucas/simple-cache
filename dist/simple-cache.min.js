module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var es6_promise_1 = __webpack_require__(1);
	var instance_1 = __webpack_require__(2);
	var instance_2 = __webpack_require__(8);
	var helpers_1 = __webpack_require__(4);
	var nodeurl = __webpack_require__(11);
	var dbug = __webpack_require__(7);
	var cache_1 = __webpack_require__(12);
	var debug = dbug('simple-url-cache');
	var CacheEngine = (function () {
	    function CacheEngine(defaultDomain, instanceName, storageConfig, cacheRules) {
	        this.defaultDomain = defaultDomain;
	        this.instanceName = instanceName;
	        this.storageConfig = storageConfig;
	        this.cacheRules = cacheRules;
	        helpers_1.default.isStringDefined(defaultDomain);
	        helpers_1.default.isStringDefined(instanceName);
	        helpers_1.default.validateCacheConfig(cacheRules);
	        if (helpers_1.default.isFS(storageConfig)) {
	            this.type = 'file';
	        }
	        else {
	            this.type = 'redis';
	        }
	        if (typeof CacheEngine.pool[this.type] === 'undefined') {
	            CacheEngine.pool[this.type] = {};
	            CacheEngine.locks[this.type] = {};
	        }
	        if (typeof CacheEngine.pool[this.type][instanceName] === 'undefined') {
	            CacheEngine.pool[this.type][instanceName] = {};
	            CacheEngine.locks[this.type][instanceName] = false;
	        }
	    }
	    CacheEngine.clearDomain = function (instanceName, storageType, domain) {
	        helpers_1.default.isStringDefined(instanceName);
	        helpers_1.default.isStringDefined(storageType);
	        helpers_1.default.isStringDefined(domain);
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            if (typeof CacheEngine.pool[storageType] === 'undefined') {
	                resolve(true);
	            }
	            if (typeof CacheEngine.pool[storageType][instanceName] === 'undefined') {
	                resolve(true);
	            }
	            var instance = CacheEngine.pool[storageType][instanceName];
	            instance.clearDomain(domain).then(function () {
	                resolve(true);
	            }, function (err) {
	                reject(err);
	            });
	        });
	    };
	    CacheEngine.clearInstance = function (instanceName, storageType) {
	        debug('celarInstance called with ', instanceName, storageType);
	        helpers_1.default.isStringDefined(instanceName);
	        helpers_1.default.isStringDefined(storageType);
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            if (typeof CacheEngine.pool[storageType] === 'undefined') {
	                resolve(true);
	            }
	            else if (typeof CacheEngine.pool[storageType][instanceName] === 'undefined') {
	                resolve(true);
	            }
	            else {
	                var instance = CacheEngine.pool[storageType][instanceName];
	                instance.clearCache().then(function () {
	                    resolve(true);
	                }, function (err) {
	                    reject(err);
	                });
	            }
	        });
	    };
	    CacheEngine.getStoredHostnames = function (instanceName, storageType) {
	        helpers_1.default.isStringDefined(instanceName);
	        helpers_1.default.isStringDefined(storageType);
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            if (typeof CacheEngine.pool[storageType] === 'undefined') {
	                resolve([]);
	            }
	            if (typeof CacheEngine.pool[storageType][instanceName] === 'undefined') {
	                resolve([]);
	            }
	            var instance = CacheEngine.pool[storageType][instanceName];
	            instance.getCachedDomains().then(function (domains) {
	                resolve(domains);
	            }, function (err) {
	                reject(err);
	            });
	        });
	    };
	    CacheEngine.getStoredURLs = function (instanceName, storageType, domain) {
	        helpers_1.default.isStringDefined(instanceName);
	        helpers_1.default.isStringDefined(storageType);
	        helpers_1.default.isStringDefined(domain);
	        debug('calling getStoredURLs with', instanceName, storageType, domain);
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            if (typeof CacheEngine.pool[storageType] === 'undefined') {
	                resolve([]);
	            }
	            if (typeof CacheEngine.pool[storageType][instanceName] === 'undefined') {
	                resolve([]);
	            }
	            var instance = CacheEngine.pool[storageType][instanceName];
	            instance.getCachedURLs(domain).then(function (urls) {
	                resolve(urls);
	            }, function (err) {
	                reject(err);
	            });
	        });
	    };
	    CacheEngine.prototype.url = function (url) {
	        helpers_1.default.isStringDefined(url);
	        var instance;
	        var parsedURL = nodeurl.parse(url);
	        var relativeURL = parsedURL.path;
	        if (!/\//.test(relativeURL)) {
	            relativeURL = '/' + relativeURL;
	        }
	        parsedURL.pathname = null;
	        parsedURL.path = null;
	        parsedURL.hash = null;
	        parsedURL.query = null;
	        parsedURL.search = null;
	        var domain = nodeurl.format(parsedURL);
	        if (domain === relativeURL) {
	            throw new Error('The url ' + url + ' is not valid');
	        }
	        if (domain.length === 0) {
	            debug('This url', url, ' has no domain, using defaultDomain = ', this.defaultDomain);
	            domain = this.defaultDomain;
	        }
	        else {
	            debug('This URL ', url, ' has a domain: ', domain);
	        }
	        instance = this.getInstance();
	        return new cache_1.default(domain, instance, relativeURL);
	    };
	    CacheEngine.prototype.getInstance = function () {
	        if (typeof CacheEngine.pool[this.type][this.instanceName] === 'undefined') {
	            CacheEngine.pool[this.type][this.instanceName] = {};
	            CacheEngine.locks[this.type][this.instanceName] = {};
	        }
	        if (helpers_1.default.isFS(this.storageConfig)) {
	            CacheEngine.pool[this.type][this.instanceName] = new instance_1.default(this.instanceName, this.storageConfig, this.cacheRules);
	        }
	        else {
	            CacheEngine.pool[this.type][this.instanceName] = new instance_2.default(this.instanceName, this.storageConfig, this.cacheRules);
	        }
	        return CacheEngine.pool[this.type][this.instanceName];
	    };
	    CacheEngine.pool = {};
	    CacheEngine.locks = {};
	    CacheEngine.helpers = {
	        validateFileStorageConfig: helpers_1.default.validateFileStorageConfig,
	        validateRedisStorageConfig: helpers_1.default.validateRedisStorageConfig,
	        validateCacheConfig: helpers_1.default.validateCacheConfig
	    };
	    return CacheEngine;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CacheEngine;
	module.exports = CacheEngine;


/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = require("es6-promise");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var es6_promise_1 = __webpack_require__(1);
	var interfaces_1 = __webpack_require__(3);
	var fs = __webpack_require__(5);
	var path = __webpack_require__(6);
	var debg = __webpack_require__(7);
	var helpers_1 = __webpack_require__(4);
	var debug = debg('simple-url-cache-FS');
	var FileStorageInstance = (function (_super) {
	    __extends(FileStorageInstance, _super);
	    function FileStorageInstance(instanceName, config, rules) {
	        _super.call(this, instanceName, config);
	        this.config = config;
	        this.rules = rules;
	        debug('Creating a new FileStorage Instance with instancename ', instanceName);
	        this.validateStorageConfig();
	    }
	    FileStorageInstance.prototype.clearCache = function () {
	        var _this = this;
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            try {
	                if (!fs.existsSync(_this.baseDir)) {
	                    resolve(true);
	                }
	                try {
	                    fs.removeSync(_this.baseDir);
	                    resolve(true);
	                }
	                catch (e) {
	                    reject(e);
	                }
	            }
	            catch (e) {
	                debug('error while emptying directory', _this.baseDir, e);
	                reject(e);
	            }
	        });
	    };
	    FileStorageInstance.prototype.getCachedDomains = function () {
	        var _this = this;
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            try {
	                if (!fs.existsSync(_this.baseDir)) {
	                    resolve([]);
	                }
	                var list = fs.readdirSync(path.resolve(path.join(_this.config.dir, helpers_1.default.escapeURL(_this.instanceName))));
	                if (list.length === 0) {
	                    ;
	                    resolve([]);
	                }
	                var results_1 = [];
	                list.forEach(function (dir) {
	                    results_1.push(helpers_1.default.unescapeURL(dir));
	                });
	                resolve(results_1);
	            }
	            catch (e) {
	                debug('Error while reading dir', _this.config.dir);
	                reject(e);
	            }
	        });
	    };
	    FileStorageInstance.prototype.getCacheRules = function () {
	        return this.rules;
	    };
	    FileStorageInstance.prototype.getCachedURLs = function (domain) {
	        var _this = this;
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            try {
	                if (!fs.existsSync(_this.getFileDir(domain))) {
	                    resolve([]);
	                }
	                var list = fs.readdirSync(_this.getFileDir(domain));
	                for (var i in list) {
	                    list[i] = helpers_1.default.unescapeURL(list[i]);
	                }
	                resolve(list);
	            }
	            catch (e) {
	                debug('Error while reading dir', _this.baseDir);
	                reject(e);
	            }
	        });
	    };
	    FileStorageInstance.prototype.delete = function (domain, url) {
	        var _this = this;
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            try {
	                fs.unlinkSync(_this.getFilePath(domain, url));
	                resolve(true);
	            }
	            catch (e) {
	                reject(e);
	            }
	        });
	    };
	    FileStorageInstance.prototype.clearDomain = function (domain) {
	        var _this = this;
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            try {
	                if (fs.existsSync(_this.getFileDir(domain))) {
	                    try {
	                        fs.removeSync(_this.getFileDir(domain));
	                        resolve(true);
	                    }
	                    catch (e) {
	                        reject(e);
	                    }
	                }
	                else {
	                    resolve(true);
	                }
	            }
	            catch (e) {
	                debug('error checing existing, but rsolving true', e);
	                resolve(true);
	            }
	        });
	    };
	    FileStorageInstance.prototype.destroy = function () { };
	    FileStorageInstance.prototype.get = function (domain, url, category, ttl) {
	        var _this = this;
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            _this.has(domain, url, category, ttl).then(function (isCached) {
	                if (!isCached) {
	                    reject();
	                }
	                else {
	                    resolve(fs.readFileSync(_this.getFilePath(domain, url), 'utf8'));
	                }
	            });
	        });
	    };
	    ;
	    FileStorageInstance.prototype.has = function (domain, url, category, ttl) {
	        var _this = this;
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            var filePath = _this.getFilePath(domain, url);
	            try {
	                if (!fs.existsSync(_this.baseDir)) {
	                    resolve(false);
	                }
	                if (!fs.existsSync(_this.getFileDir(domain))) {
	                    resolve(false);
	                }
	                var exist = fs.existsSync(filePath);
	                if (exist) {
	                    if (category === 'maxAge') {
	                        var stats = fs.statSync(filePath);
	                        var nowTimestamp = new Date().getTime();
	                        var modificationTime = stats.mtime.getTime();
	                        var expiration = modificationTime + ttl * 1000;
	                        var diff = (nowTimestamp - expiration);
	                        if (diff > 0) {
	                            debug('This url is expired.... removing the cache. ', filePath);
	                            _this.delete(domain, url).then(function (ok) {
	                                resolve(false);
	                            }, function (err) {
	                                reject(err);
	                            });
	                        }
	                        else {
	                            resolve(true);
	                        }
	                    }
	                    else {
	                        resolve(true);
	                    }
	                }
	                else {
	                    resolve(false);
	                }
	            }
	            catch (e) {
	                debug(e);
	                reject(e);
	            }
	        });
	    };
	    FileStorageInstance.prototype.set = function (domain, url, value, category, ttl, force) {
	        var _this = this;
	        var filePath = this.getFilePath(domain, url);
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            if (force === true) {
	                try {
	                    fs.ensureDirSync(_this.getFileDir(domain));
	                    _this.has(domain, url, category, ttl).then(function (has) {
	                        try {
	                            if (has) {
	                                fs.removeSync(filePath);
	                            }
	                            fs.writeFileSync(filePath, value, 'utf-8');
	                            resolve(true);
	                        }
	                        catch (e) {
	                            reject(e);
	                        }
	                    }, function (err) {
	                        reject(err);
	                    });
	                }
	                catch (e) {
	                    debug(e);
	                    reject(e);
	                }
	                return;
	            }
	            if (category === 'never') {
	                debug('this url should never been stored');
	                resolve(false);
	                return;
	            }
	            _this.has(domain, url, category, ttl).then(function (has) {
	                if (has) {
	                    resolve(false);
	                }
	                try {
	                    fs.ensureDirSync(_this.getFileDir(domain));
	                    fs.writeFileSync(filePath, value, 'utf-8');
	                    resolve(true);
	                }
	                catch (e) {
	                    debug(e);
	                    reject(e);
	                }
	            }, function (err) {
	                reject(err);
	            });
	        });
	    };
	    FileStorageInstance.prototype.getFileDir = function (domain) {
	        return path.join(this.baseDir, helpers_1.default.escapeURL(domain));
	    };
	    FileStorageInstance.prototype.getFilePath = function (domain, url) {
	        var file = helpers_1.default.escapeURL(url);
	        if (helpers_1.default.validateURL(file)) {
	            return path.join(this.getFileDir(domain), file);
	        }
	        else {
	            throw new Error('Invalid file');
	        }
	    };
	    FileStorageInstance.prototype.validateStorageConfig = function () {
	        helpers_1.default.validateFileStorageConfig(this.config);
	        this.baseDir = path.resolve(path.join(this.config.dir, helpers_1.default.escapeURL(this.instanceName)));
	        fs.ensureDirSync(this.baseDir);
	    };
	    FileStorageInstance.filePaths = {};
	    return FileStorageInstance;
	}(interfaces_1.StorageInstance));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = FileStorageInstance;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var helpers_1 = __webpack_require__(4);
	var StorageInstance = (function () {
	    function StorageInstance(instanceName, config) {
	        this.instanceName = instanceName;
	        if (helpers_1.default.isFS(config)) {
	            this.storageType = 'file';
	        }
	        else {
	            this.storageType = 'redis';
	        }
	    }
	    StorageInstance.prototype.getStorageType = function () {
	        return this.storageType;
	    };
	    StorageInstance.prototype.getInstanceName = function () {
	        return this.instanceName;
	    };
	    return StorageInstance;
	}());
	exports.StorageInstance = StorageInstance;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	var Helpers = (function () {
	    function Helpers() {
	    }
	    Helpers.isFS = function (storageConfig) {
	        return typeof storageConfig.dir !== 'undefined';
	    };
	    Helpers.escapeURL = function (key) {
	        var escaped = key.replace(':', '%3A');
	        escaped = escaped.replace('.', '%2E');
	        escaped = escaped.replace('~', '%7E');
	        escaped = encodeURIComponent(escaped);
	        return escaped;
	    };
	    ;
	    Helpers.unescapeURL = function (key) {
	        var unescaped = decodeURIComponent(key);
	        unescaped = unescaped.replace('%3A', ':');
	        unescaped = unescaped.replace('%2E', '.');
	        unescaped = unescaped.replace('%7E', '~');
	        return unescaped;
	    };
	    Helpers.validateURL = function (key) {
	        if (key.length === 0) {
	            return false;
	        }
	        if (key.length > 255) {
	            return false;
	        }
	        if (typeof key === 'undefined') {
	            return false;
	        }
	        return true;
	    };
	    ;
	    Helpers.isStringDefined = function (input) {
	        if (typeof input !== 'string' || input.length === 0) {
	            Helpers.invalidParameterError('this should be a non empty string', input);
	        }
	    };
	    Helpers.isStringIn = function (input, values) {
	        if (typeof input !== 'string') {
	            return false;
	        }
	        var valid = false;
	        values.forEach(function (value) {
	            if (value === input) {
	                valid = true;
	            }
	        });
	        if (!valid) {
	            Helpers.invalidParameterError('This string should contain only these values : ' + values.join(', '), input);
	        }
	    };
	    Helpers.isArray = function (data) {
	        if ((data instanceof Array) === false) {
	            Helpers.invalidParameterError('This should be an array', data);
	        }
	    };
	    Helpers.isRegexRule = function (data) {
	        if ((data.regex instanceof RegExp) === false) {
	            Helpers.invalidParameterError('This should be a Regexp', data);
	        }
	    };
	    Helpers.hasMaxAge = function (data) {
	        if (typeof data.maxAge !== 'number') {
	            Helpers.invalidParameterError('This rule misses a maxAge property', data);
	        }
	    };
	    Helpers.isOptionalBoolean = function (data) {
	        if (typeof data !== 'undefined' && typeof data !== 'boolean') {
	            Helpers.invalidParameterError('You provided an optional boolean but this is not a boolean', data);
	        }
	    };
	    Helpers.validateCacheConfig = function (cacheRules) {
	        Helpers.isStringIn(cacheRules.default, ['always', 'never']);
	        ['always', 'never', 'maxAge'].forEach(function (type) {
	            Helpers.isArray(cacheRules[type]);
	            cacheRules[type].forEach(function (rule) {
	                Helpers.isRegexRule(rule);
	                if (type === 'maxAge') {
	                    Helpers.hasMaxAge(rule);
	                }
	            });
	        });
	    };
	    Helpers.validateFileStorageConfig = function (data) {
	        Helpers.isStringDefined(data.dir);
	    };
	    Helpers.validateRedisStorageConfig = function (data) {
	    };
	    Helpers.invalidParameterError = function (name, value) {
	        throw new TypeError('Invalid parameter: ' + name + '. Value received: ' + JSON.stringify(value));
	    };
	    return Helpers;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Helpers;


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("fs-extra");

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("debug");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var interfaces_1 = __webpack_require__(3);
	var pool_1 = __webpack_require__(9);
	var debg = __webpack_require__(7);
	var debug = debg('simple-url-cache-REDIS');
	var es6_promise_1 = __webpack_require__(1);
	var RedisStorageInstance = (function (_super) {
	    __extends(RedisStorageInstance, _super);
	    function RedisStorageInstance(instanceName, config, rules) {
	        _super.call(this, instanceName, config);
	        this.config = config;
	        this.rules = rules;
	        this.validateStorageConfig();
	        this.hashKey = 'simple-url-cache:' + this.instanceName;
	    }
	    RedisStorageInstance.prototype.clearCache = function () {
	        throw 'TODO';
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            reject('PB');
	        });
	    };
	    RedisStorageInstance.prototype.clearDomain = function (domain) {
	        var _this = this;
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            var client = _this._conn.getConnection();
	            debug('Clear all cache called');
	            client.hdel(_this.hashKey, domain, function (err) {
	                if (err)
	                    reject(err);
	                client.hkeys(_this.getDomainHashKey(domain), function (err, urls) {
	                    debug('getting keys for ', _this.getDomainHashKey(domain), urls);
	                    var nb = 0;
	                    if (urls.length === 0) {
	                        resolve(true);
	                    }
	                    var promises = [];
	                    urls.forEach(function (url) {
	                        debug('Deleting key ', _this.getUrlKey(domain, url));
	                        promises.push(_this.delete(domain, url));
	                        es6_promise_1.Promise.all(promises).then(function () {
	                            resolve(true);
	                        }, function (err) {
	                            reject(err);
	                        });
	                    });
	                });
	            });
	        });
	    };
	    RedisStorageInstance.prototype.getCachedDomains = function () {
	        var _this = this;
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            debug('getAllCachedDomains called');
	            _this._conn.getConnection().hkeys(_this.hashKey, function (err, results) {
	                if (err)
	                    reject(err);
	                debug('hkeys() ', _this.hashKey, results);
	                resolve(results);
	            });
	        });
	    };
	    RedisStorageInstance.prototype.getCacheRules = function () {
	        return this.rules;
	    };
	    RedisStorageInstance.prototype.getCachedURLs = function (domain) {
	        var _this = this;
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            var client = _this._conn.getConnection();
	            var cachedUrls = [];
	            var promises = [];
	            client.hkeys(_this.getDomainHashKey(domain), function (err, urls) {
	                if (err)
	                    reject(err);
	                if (urls.length === 0) {
	                    resolve(cachedUrls);
	                }
	                urls.forEach(function (url) {
	                    promises.push(client.get(_this.getUrlKey(domain, url), function (err, data) {
	                        if (err)
	                            reject(err);
	                        if (data !== null) {
	                            cachedUrls.push(url);
	                        }
	                        else {
	                            client.hdel(_this.getDomainHashKey(domain), url, function (err) {
	                                if (err)
	                                    reject(err);
	                            });
	                        }
	                    }));
	                    es6_promise_1.Promise.all(promises).then(function () {
	                        resolve(cachedUrls);
	                    }, function (err) {
	                        reject(err);
	                    });
	                });
	            });
	        });
	    };
	    RedisStorageInstance.prototype.delete = function (domain, url) {
	        var _this = this;
	        debug('removing url cache: ', domain, url);
	        var client = this._conn.getConnection();
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            _this.has(domain, url).then(function (isCached) {
	                if (!isCached) {
	                    reject();
	                }
	                else {
	                    client.del(_this.getUrlKey(domain, url), function (err) {
	                        if (err) {
	                            debug('REDIS ERROR, ', err);
	                            reject(err);
	                        }
	                        debug('DELETING HASH ', _this.getDomainHashKey(domain));
	                        client.hdel(_this.getDomainHashKey(domain), url, function (err) {
	                            if (err) {
	                                debug('REDIS ERROR', err);
	                                reject(err);
	                            }
	                            resolve(true);
	                        });
	                    });
	                }
	            }, function (err) {
	                reject(err);
	            });
	        });
	    };
	    RedisStorageInstance.prototype.destroy = function () {
	        this._conn.kill();
	    };
	    RedisStorageInstance.prototype.get = function (domain, url) {
	        var _this = this;
	        debug('Retrieving url cache: ', domain, url);
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            var client = _this._conn.getConnection();
	            client.hget(_this.getDomainHashKey(domain), url, function (err, content) {
	                if (err)
	                    reject(err);
	                if (content === null) {
	                    reject(null);
	                }
	                client.get(_this.getUrlKey(domain, url), function (err, timestamp) {
	                    if (err)
	                        reject(err);
	                    if (timestamp === null) {
	                        client.hdel(_this.getDomainHashKey(domain), _this.getUrlKey(domain, url), function (err) {
	                            if (err)
	                                reject(err);
	                            reject(null);
	                        });
	                    }
	                    else {
	                        resolve(content);
	                    }
	                });
	            });
	        });
	    };
	    RedisStorageInstance.prototype.has = function (domain, url) {
	        var _this = this;
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            var client = _this._conn.getConnection();
	            client.get(_this.getUrlKey(domain, url), function (err, data) {
	                if (err) {
	                    debug('Error while querying is cached on redis: ', domain, url, err);
	                    reject(err);
	                }
	                else {
	                    var isCached = data !== null;
	                    debug('HAS, key ', _this.getUrlKey(domain, url), 'is cached? ', isCached);
	                    if (!isCached) {
	                        client.hdel(_this.getDomainHashKey(domain), url, function (err) {
	                            debug('hdel executed', _this.getDomainHashKey(domain), url);
	                            if (err) {
	                                reject(err);
	                            }
	                            resolve(false);
	                        });
	                    }
	                    else {
	                        resolve(true);
	                    }
	                }
	            });
	        });
	    };
	    RedisStorageInstance.prototype.set = function (domain, url, value, category, ttl, force) {
	        var _this = this;
	        var client = this._conn.getConnection();
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            if (force === true) {
	                var ttl_1 = 0;
	                _this.store(domain, url, value, ttl_1, force).then(function (result) {
	                    resolve(result);
	                }, function (err) {
	                    reject(err);
	                });
	                return;
	            }
	            if (category === 'never') {
	                debug('this url should never been stored');
	                resolve(false);
	                return;
	            }
	            _this.has(domain, url).then(function (has) {
	                if (has === true) {
	                    debug('This url is already cached - not storing it: ', domain, url);
	                    resolve(false);
	                }
	                else {
	                    _this.store(domain, url, value, ttl, force).then(function (result) {
	                        resolve(result);
	                    }, function (err) {
	                        reject(err);
	                    });
	                }
	            }, function (err) {
	                reject(err);
	            });
	        });
	    };
	    RedisStorageInstance.prototype.getDomainHashKey = function (domain) {
	        return this.hashKey + ':' + domain;
	    };
	    RedisStorageInstance.prototype.store = function (domain, url, value, ttl, force) {
	        var _this = this;
	        var client = this._conn.getConnection();
	        return new es6_promise_1.Promise(function (resolve, reject) {
	            client.hset(_this.hashKey, domain, domain, function (err, result) {
	                if (err) {
	                    reject(err);
	                }
	                else {
	                    client.hset(_this.getDomainHashKey(domain), url, value, function (err, exists) {
	                        if (err) {
	                            reject(err);
	                        }
	                        if (exists === 0) {
	                            debug('Already set ');
	                            resolve(true);
	                            return;
	                        }
	                        else {
	                            client.get(_this.getUrlKey(domain, url), function (err, result) {
	                                if (err) {
	                                    reject(err);
	                                    return;
	                                }
	                                if (result === null) {
	                                    debug('REDIS timestamp not set');
	                                    client.set(_this.getUrlKey(domain, url), Date.now(), function (err) {
	                                        if (err) {
	                                            reject(err);
	                                            return;
	                                        }
	                                        if (ttl > 0) {
	                                            client.expire(_this.getUrlKey(domain, url), ttl, function (err) {
	                                                if (err)
	                                                    reject(err);
	                                                resolve(true);
	                                            });
	                                        }
	                                        else {
	                                            resolve(true);
	                                        }
	                                    });
	                                }
	                                else if (force === true) {
	                                    if (ttl > 0) {
	                                        client.expire(_this.getUrlKey(domain, url), ttl, function (err) {
	                                            if (err)
	                                                reject(err);
	                                            resolve(true);
	                                        });
	                                    }
	                                    else {
	                                        resolve(true);
	                                    }
	                                }
	                            });
	                        }
	                    });
	                }
	            });
	        });
	    };
	    RedisStorageInstance.prototype.validateStorageConfig = function () {
	        this._conn = new pool_1.RedisPool(this.config);
	    };
	    RedisStorageInstance.prototype.getUrlKey = function (domain, url) {
	        return this.getDomainHashKey(domain) + ':' + url;
	    };
	    return RedisStorageInstance;
	}(interfaces_1.StorageInstance));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RedisStorageInstance;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var redis = __webpack_require__(10);
	var dbug = __webpack_require__(7);
	var debug = dbug('simple-url-cache-REDIS');
	var RedisPool = (function () {
	    function RedisPool(config) {
	        RedisPool.connect(config);
	        this.db = config.db;
	    }
	    RedisPool.connect = function (config) {
	        if (typeof RedisPool._pool[config.db] === 'undefined' || RedisPool._pool[config.db] === null || !RedisPool._isOnline[config.db]) {
	            debug('This redis connection has never been instanciated before', config.db);
	            RedisPool._isOnline[config.db] = false;
	            RedisPool._pool[config.db] = redis.createClient(config);
	            RedisPool._pool[config.db].on('connect', function () {
	                RedisPool._isOnline[config.db] = true;
	                debug('redis connected');
	            });
	            RedisPool._pool[config.db].on('error', function (e) {
	                debug(e);
	                RedisPool._isOnline[config.db] = false;
	                RedisPool._pool[config.db] = null;
	                throw new Error(e);
	            });
	            RedisPool._pool[config.db].on('end', function () {
	                RedisPool._pool[config.db] = null;
	                RedisPool._isOnline[config.db] = false;
	                debug('Connection closed');
	            });
	            RedisPool._pool[config.db].on('warning', function (msg) {
	                debug('Warning called: ', msg);
	            });
	        }
	        return RedisPool._pool[config.db];
	    };
	    RedisPool.isOnline = function (db) {
	        return RedisPool._isOnline[db];
	    };
	    RedisPool.kill = function (db) {
	        if (RedisPool._isOnline[db] === true) {
	            RedisPool._pool[db].end();
	        }
	    };
	    RedisPool.prototype.getConnection = function () {
	        return RedisPool._pool[this.db];
	    };
	    RedisPool.prototype.isOnline = function () {
	        return RedisPool._isOnline[this.db];
	    };
	    RedisPool.prototype.kill = function () {
	        if (RedisPool._isOnline[this.db] === true) {
	            RedisPool._pool[this.db].end();
	        }
	    };
	    RedisPool._pool = {};
	    RedisPool._isOnline = {};
	    return RedisPool;
	}());
	exports.RedisPool = RedisPool;


/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = require("redis");

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = require("url");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var helpers_1 = __webpack_require__(4);
	var Cache = (function () {
	    function Cache(_domain, _storageInstance, _url) {
	        var _this = this;
	        this._domain = _domain;
	        this._storageInstance = _storageInstance;
	        this._url = _url;
	        this._category = '';
	        this._maxAge = 0;
	        this.delete = function () {
	            return _this.getStorageInstance().delete(_this._domain, _this._url);
	        };
	        this.get = function () {
	            return _this.getStorageInstance().get(_this._domain, _this._url, _this._category, _this._maxAge);
	        };
	        this.has = function () {
	            return _this.getStorageInstance().has(_this._domain, _this._url, _this._category, _this._maxAge);
	        };
	        this.set = function (html, force) {
	            helpers_1.default.isStringDefined(html);
	            helpers_1.default.isOptionalBoolean(force);
	            if (typeof force === 'undefined') {
	                force = false;
	            }
	            return _this.getStorageInstance().set(_this._domain, _this._url, html, _this._category, _this._maxAge, force);
	        };
	        this.getRegexTest = function (u) {
	            return u.regex.test(_this._url);
	        };
	        this._config = this._storageInstance.getCacheRules();
	        this.setCacheCategory();
	    }
	    Cache.prototype.getDomain = function () {
	        return this._domain;
	    };
	    Cache.prototype.getCategory = function () {
	        return this._category;
	    };
	    Cache.prototype.getInstanceName = function () {
	        return this._storageInstance.getInstanceName();
	    };
	    Cache.prototype.getStorageType = function () {
	        return this._storageInstance.getStorageType();
	    };
	    Cache.prototype.getUrl = function () {
	        return this._url;
	    };
	    Cache.prototype.setCacheCategory = function () {
	        var i;
	        for (i in this._config.maxAge) {
	            if (this.getRegexTest(this._config.maxAge[i]) === true) {
	                this._category = 'maxAge';
	                this._maxAge = this._config.maxAge[i].maxAge;
	            }
	        }
	        for (i in this._config.always) {
	            if (this.getRegexTest(this._config.always[i]) === true) {
	                if (this._category.length > 0) {
	                    console.warn('This url has already matched against a regex', this._url);
	                }
	                if (this._category !== 'always') {
	                    console.error('And overriding maxAge with always');
	                }
	                this._category = 'always';
	            }
	        }
	        for (i in this._config.never) {
	            if (this.getRegexTest(this._config.never[i]) === true) {
	                if (this._category.length > 0) {
	                    console.warn('This url has already matched against a regex', this._url);
	                }
	                if (this._category !== 'always') {
	                    console.error('And overriding maxAge/Always with mever');
	                }
	                this._category = 'never';
	            }
	        }
	        if (this._category.length === 0) {
	            this._category = this._config.default;
	        }
	    };
	    ;
	    Cache.prototype.getStorageInstance = function () {
	        return this._storageInstance;
	    };
	    return Cache;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Cache;


/***/ }
/******/ ]);
//# sourceMappingURL=simple-cache.min.js.map