module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const fileStorage_1 = __webpack_require__(1);
	const redisStorage_1 = __webpack_require__(8);
	class CacheEngine {
	    constructor(storageConfig, cacheRules) {
	        this.storageConfig = storageConfig;
	        this.cacheRules = cacheRules;
	    }
	    url(url) {
	        switch (this.storageConfig.type) {
	            case 'file':
	                return new fileStorage_1.default(url, this.storageConfig, this.cacheRules);
	            case 'redis':
	                return new redisStorage_1.default(url, this.storageConfig, this.cacheRules);
	            default:
	                throw new Error('Unknown Storage config type value. Only file|redis allowed');
	        }
	    }
	}
	exports.CacheEngine = CacheEngine;
	;


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const abstract_1 = __webpack_require__(2);
	const path = __webpack_require__(3);
	const fs = __webpack_require__(4);
	const shell = __webpack_require__(5);
	const es6_promise_1 = __webpack_require__(6);
	const dbug = __webpack_require__(7);
	let debug = dbug('simple-url-cache-FS');
	es6_promise_1.polyfill();
	class FileStorage extends abstract_1.CacheCategory {
	    constructor(_url, _storageConfig, _regexRules) {
	        super(_url, _regexRules);
	        this._url = _url;
	        this._storageConfig = _storageConfig;
	        this._regexRules = _regexRules;
	        this.escape = () => {
	            let escaped = this._url.replace(':', '%3A');
	            escaped = escaped.replace('.', '%2E'); //http://stackoverflow.com/questions/3856693/a-url-resource-that-is-a-dot-2e
	            escaped = escaped.replace('~', '%7E'); //http://www.w3schools.com/tags/ref_urlencode.asp
	            escaped = encodeURIComponent(escaped);
	            return escaped;
	        };
	        this.validate = (str) => {
	            if (str.length === 0) {
	                return false;
	            }
	            if (str.length > 255) {
	                return false;
	            }
	            if (typeof str === 'undefined') {
	                return false;
	            }
	            return true;
	        };
	        this.isCached = () => {
	            return new Promise((resolve, reject) => {
	                if (fs.existsSync(this._currentFilePath)) {
	                    if (this._currentCategory === 'maxAge') {
	                        var stats = fs.statSync(this._currentFilePath);
	                        var nowTimestamp = new Date().getTime();
	                        var modificationTime = stats.mtime.getTime();
	                        var expiration = modificationTime + this._currentMaxAge * 1000;
	                        var diff = (nowTimestamp - expiration);
	                        this.diff = diff;
	                        if (diff > 0) {
	                            //the file is expired, remove it, then return false;
	                            this.removeUrl();
	                            debug('This url is expired.... removing the cache. ', this._url);
	                            resolve(false);
	                        }
	                        else {
	                            debug('This url is cached.', this._url);
	                            resolve(true);
	                        }
	                    }
	                    debug('This url is cached ', this._url);
	                    resolve(true);
	                }
	                else {
	                    debug('This url is not cached ', this._url);
	                    resolve(false);
	                }
	            });
	        };
	        this.removeUrl = () => {
	            debug('removing url cache: ', this._url);
	            return new Promise((resolve, reject) => {
	                try {
	                    fs.unlinkSync(this._currentFilePath);
	                    resolve(true);
	                }
	                catch (e) {
	                    debug('Error while removing url: ', this._url, e);
	                    reject(false);
	                }
	            });
	        };
	        this.getUrl = () => {
	            debug('Retrieving url cache: ', this._url);
	            return new Promise((resolve, reject) => {
	                this.isCached().then((isCached) => {
	                    if (!isCached) {
	                        reject('This url is not cached: ' + this._url);
	                    }
	                    else {
	                        resolve(fs.readFileSync(this._currentFilePath, 'utf8'));
	                    }
	                });
	            });
	        };
	        this.cache = (html, force) => {
	            debug('Caching url ', this._url);
	            return new Promise((resolve, reject) => {
	                if (!this._validFile) {
	                    debug('FILE -> ' + 'invalid REJECTED', this._url);
	                    reject('invalid URL');
	                    return;
	                }
	                else {
	                    if (force === true) {
	                        fs.writeFile(this._currentFilePath, html, 'utf8', (err) => {
	                            if (err) {
	                                debug('Error while writing cache.', this._url, err);
	                                reject('invalid URL');
	                            }
	                            else {
	                                debug('URL cached sucessfully: ', this._url);
	                                resolve(true);
	                            }
	                        });
	                        return;
	                    }
	                    this.isCached().then((isCached) => {
	                        if (isCached) {
	                            resolve(false);
	                        }
	                        else {
	                            if (this._currentCategory === 'never') {
	                                debug('Won\'t cache the url - category is never.', this._url);
	                                resolve(false);
	                                return;
	                            }
	                            fs.writeFile(this._currentFilePath, html, 'utf8', (err) => {
	                                if (err) {
	                                    debug('Error while writing cache.', this._url, err);
	                                    reject('invalid URL');
	                                }
	                                else {
	                                    debug('URL cached sucessfully: ', this._url);
	                                    resolve(true);
	                                }
	                            });
	                        }
	                    });
	                }
	            });
	        };
	        this.destroy = () => { };
	        shell.mkdir('-p', this._storageConfig.dir);
	        let escaped = this.escape();
	        this._validFile = this.validate(escaped);
	        this._currentFilePath = path.join(this._storageConfig.dir, escaped);
	        debug('FileStorage instanciated with url: ' + this._url);
	        debug('_currentFilePath = ', this._currentFilePath);
	    }
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = FileStorage;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	class CacheCategory {
	    constructor(currentUrl, _config) {
	        this.currentUrl = currentUrl;
	        this._config = _config;
	        this.getRegexTest = (u) => {
	            return u.regex.test(this.currentUrl);
	        };
	        //return always|never|maxAge|timestamp|default
	        this.getCacheCategory = () => {
	            var i;
	            for (i in this._config.cacheNever) {
	                if (this.getRegexTest(this._config.cacheNever[i]) === true) {
	                    this._currentCategory = 'never';
	                    return;
	                }
	            }
	            for (i in this._config.cacheAlways) {
	                if (this.getRegexTest(this._config.cacheAlways[i]) === true) {
	                    this._currentCategory = 'always';
	                    return;
	                }
	            }
	            for (i in this._config.cacheMaxAge) {
	                if (this.getRegexTest(this._config.cacheMaxAge[i]) === true) {
	                    this._currentCategory = 'maxAge';
	                    this._currentMaxAge = this._config.cacheMaxAge[i].maxAge;
	                    return;
	                }
	            }
	            this._currentCategory = this._config.default;
	            return;
	        };
	        this.getCacheCategory();
	    }
	    getCategory() {
	        return this._currentCategory;
	    }
	    getCurrentUrl() {
	        return this.currentUrl;
	    }
	}
	exports.CacheCategory = CacheCategory;


/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("shelljs");

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("es6-promise");

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("debug");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const abstract_1 = __webpack_require__(2);
	const es6_promise_1 = __webpack_require__(6);
	const dbug = __webpack_require__(7);
	const redisPool_1 = __webpack_require__(9);
	es6_promise_1.polyfill();
	let debug = dbug('simple-url-cache-REDIS');
	class RedisStorage extends abstract_1.CacheCategory {
	    constructor(_url, _storageConfig, _regexRules) {
	        super(_url, _regexRules);
	        this._url = _url;
	        this._storageConfig = _storageConfig;
	        this._regexRules = _regexRules;
	        this.isRedisOnline = () => {
	            return redisPool_1.RedisPool.isOnline();
	        };
	        this.isCached = () => {
	            return new Promise((resolve, reject) => {
	                this._conn.get(this._url, (err, data) => {
	                    if (err) {
	                        debug('Error while querying is cached on redis: ', this._url, err);
	                        reject(err);
	                    }
	                    else {
	                        let isCached = data !== null;
	                        resolve(isCached);
	                    }
	                });
	            });
	        };
	        this.removeUrl = () => {
	            debug('removing url cache: ', this._url);
	            return new Promise((resolve, reject) => {
	                this._conn.del(this._url, (err, data) => {
	                    if (err) {
	                        debug('Error while removing url: ', this._url, err);
	                        reject(err);
	                    }
	                    resolve(true);
	                });
	            });
	        };
	        this.getUrl = () => {
	            debug('Retrieving url cache: ', this._url);
	            return new Promise((resolve, reject) => {
	                this._conn.get(this._url, (err, data) => {
	                    if (err) {
	                        debug('Error while retrieving url: ', this._url, err);
	                        reject(err);
	                    }
	                    if (data === null) {
	                        debug('This url is not cached - and can\'t be retrieved: ', this._url);
	                        reject('This url is not cached: ' + this._url);
	                    }
	                    else {
	                        resolve(data);
	                    }
	                });
	            });
	        };
	        this.cache = (html, force) => {
	            debug('Caching url ', this._url);
	            return new Promise((resolve, reject) => {
	                if (force === true) {
	                    this._conn.set(this._url, html, (err, result) => {
	                        if (err) {
	                            debug('Error while storing url in redis: ', this._url, err);
	                            reject(err);
	                        }
	                        if (this._currentCategory === 'maxAge') {
	                            this._conn.expire(this._url, this._currentMaxAge, (err) => {
	                                if (err) {
	                                    debug('Error while setting ttl in redis: ', this._url, err);
	                                    reject(err);
	                                }
	                                else {
	                                    debug('URL cached successfully with ttl = ', this._currentMaxAge, this._url);
	                                    resolve(true);
	                                }
	                            });
	                        }
	                        else {
	                            debug('URL cached sucessfully: ', this._url);
	                            resolve(true);
	                        }
	                    });
	                }
	                else {
	                    this.isCached().then((isCached) => {
	                        if (isCached === true) {
	                            debug('This url is already cached - not storing it: ', this._url);
	                            resolve(false);
	                        }
	                        else if (this._currentCategory === 'never') {
	                            debug('Won\'t cache the url - category is never.', this._url);
	                            resolve(false);
	                        }
	                        else {
	                            this._conn.set(this._url, html, (err, result) => {
	                                if (err) {
	                                    debug('Error while storing url in redis: ', this._url, err);
	                                    reject(err);
	                                }
	                                if (this._currentCategory === 'maxAge') {
	                                    this._conn.expire(this._url, this._currentMaxAge, (err) => {
	                                        if (err) {
	                                            debug('Error while setting ttl in redis: ', this._url, err);
	                                            reject(err);
	                                        }
	                                        else {
	                                            debug('URL cached successfully with ttl = ', this._currentMaxAge, this._url);
	                                            resolve(true);
	                                        }
	                                    });
	                                }
	                                else {
	                                    debug('URL cached sucessfully: ', this._url);
	                                    resolve(true);
	                                }
	                            });
	                        }
	                    });
	                }
	            });
	        };
	        this.destroy = () => {
	            redisPool_1.RedisPool.kill();
	        };
	        this._conn = redisPool_1.RedisPool.connect(this._storageConfig);
	    }
	}
	RedisStorage._redisPool = redisPool_1.RedisPool;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RedisStorage;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const redis = __webpack_require__(10);
	const dbug = __webpack_require__(7);
	let debug = dbug('simple-url-cache-REDIS');
	let pool = null;
	var RedisPool;
	(function (RedisPool) {
	    let _isOnline = false;
	    RedisPool.connect = (config) => {
	        if (pool === null) {
	            debug('This redis connection has never been instanciated before');
	            pool = redis.createClient(config);
	            pool.on('connect', () => {
	                _isOnline = true;
	                console.log('redis connected');
	            });
	            pool.on('error', (e) => {
	                console.error(e);
	                _isOnline = true;
	                pool = null;
	                throw new Error(e);
	            });
	            pool.on('end', () => {
	                pool = null;
	                _isOnline = false;
	                console.error('Connection closed');
	            });
	            pool.on('warning', (msg) => {
	                console.error('Warning called: ', msg);
	            });
	        }
	        return pool;
	    };
	    RedisPool.isOnline = () => {
	        return pool !== null && _isOnline === true;
	    };
	    RedisPool.kill = () => {
	        if (_isOnline === true) {
	            pool.end();
	        }
	    };
	})(RedisPool = exports.RedisPool || (exports.RedisPool = {}));


/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = require("redis");

/***/ }
/******/ ]);
//# sourceMappingURL=simple-cache.min.js.map